{\rtf1\ansi\ansicpg1252\cocoartf1187\cocoasubrtf390
{\fonttbl\f0\fmodern\fcharset0 Courier;}
{\colortbl;\red255\green255\blue255;}
\paperw11900\paperh16840\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720

\f0\fs24 \cf0 Worked-out-example: Par rate sensitivity\
===============================\
\
In this example the goal is to compute par rate sensitivity to a set of benchmark instruments. The par rates or market quotes of those instruments are not given, they need to be computed from existing zero-coupon curves.\
\
Structure\
-----------\
The approach is the following. We create the benchmark instruments with 0 market quote (like an IRS with fixed rate equal to 0). For those instruments, we compute the market quote using the *ParSpreadMarketQuoteDiscountingCalculator*. The calculator computes by how much the instrument market quote should be changed to get a PV of 0. As our original instruments have a market quote of 0, the change is the total market quote quantity.\
\
Once the implied market quote for those instruments are known, a new set of curves is calibrated as usual. The output of that calibration is the new set of curve and the associated *CurveBuildingBlockBundle*. The blocks are required to computed the market quote sensitivities.\
\
The computation of the market quote sensitivities (or par rate sensitivities) is then trivial, using the *MarketQuoteSensitivityBlockCalculator*.\
\
Code\
-------\
An example of the above approach can be found in the tutorial: **ParRatePV01FromCurveAnalysis**.\
\
A forward USD swap Fixed v LIBOR3M is constructed (**IRS_1**). A standard multi-curve provider is loaded in **MULTICURVE_STD**. Note that here we don't know about the par rates of that multi-curve, it is hidden in the black box.\
\
The implied curves describe above are computed in the external class **ImpliedMulticurveSimplified**.  The main code is in the method **getCurvesUsd**; the rest of the class simply collect standard USD conventions.\
\
The first step is to create the instruments with market quote::\
\
    double[] marketQuotes0 = new double[nbNode];\
    InstrumentDefinition<?>[] definitionsDsc0 = \
      CurveCalibrationTestsUtils.getDefinitions(marketQuotes0, NOTIONAL, IRS_USD_GENERATORS, IRS_USD_ATTR, calibrationDate);\
\
Then  for each of those instruments, we compute the implied market quote from the curves::\
\
    for (int loopdsc = 0; loopdsc < nbNode; loopdsc++) \{\
      InstrumentDerivative derivative = CurveCalibrationTestsUtils.convert(definitionsDsc0[loopdsc], false, calibrationDate, TS_ARRAY_EMPTY, TS_ARRAY_EMPTY, TS_ARRAY_EMPTY, TS_ARRAY_EMPTY);\
      marketQuoteComputed[loopdsc] = derivative.accept(PSMQC, multicurve);\
    \}\
\
We recreate a second set of instruments, this time with the market quotes::\
\
    InstrumentDefinition<?>[] definitions = CurveCalibrationTestsUtils.getDefinitions(marketQuoteComputed, NOTIONAL, IRS_USD_GENERATORS, IRS_USD_ATTR, calibrationDate);\
\
We can now calibrate the curves in the normal way::\
\
    CurveCalibrationTestsUtils.makeCurvesFromDefinitionsMulticurve(calibrationDate, definitionsUnits, \
      GENERATORS_UNITS_USD, NAMES_UNITS_USD, KNOWN_DATA, PSMQC, PSMQCSC, false, DSC_MAP, \
      FWD_ON_MAP, FWD_IBOR_MAP, CURVE_BUILDING_REPOSITORY, TS_ARRAY_EMPTY, TS_ARRAY_EMPTY, TS_ARRAY_EMPTY, TS_ARRAY_EMPTY);\
\
From there computing the sensitivity to the market quote of the new instruments is simply::\
    \
    MultipleCurrencyParameterSensitivity mqsComputed = MQSBC.fromInstrument(IRS_1, MULTICURVE_SIMPLE, BLOCK_SIMPLE);\
}